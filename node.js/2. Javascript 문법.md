# 2. Javascript 문법



****



# 2.1 ES2015+



## 템플릿 문자열

'(작은 따옴표) 이 아닌 `(백틱) 으로 감싼 문자열이다. 해당 백틱 안에는 일반적인 문자열과 잘리 변수를 넣을 수 있다.

```javascript
let lastNm = '채'
let frstNm = '지훈'
let fullNm = '내이름은 ' + lastNm + frstNm + ' 입니다.'

console.log(fullNm)
//=> 실핻 결과 : 내이름은 채지훈 입니다.

let lastNm = '채'
let frstNm = '지훈'
let fullNm = `내이름은 ${lastNm}${frstNm} 입니다.`

console.log(fullNm)
//=> 실핻 결과 : 내이름은 채지훈 입니다.
```

위와 같이 기존 ' ' 를 사용하는 경우보다 간편하게 코드를 작성할 수 있다.





## 객체 리터럴

기존의 경우 객체를 사용할때

```javascript
let sayNode = function () {
  console.log("Node");
};
let es = 'ES';
let oldObject = {
	sayJS: function() {
		console.log('JS');
	},
	sayNode: sayNode,
};

oldObject[es + 6] = 'Fantastic';
oldObject.sayNode();
oldObject.sayJS();
console.log(oldObject.ES6);
```

 위와 같이 객체에 동적으로 속성을 추가하였다.

이코드를 다음과 같이 다시 쓸 수 있다.

```js
const newObject = {
	sayJS() {
		console.log('JS');
	},
	sayNode,
	[es + 6]: 'Fantastic',
};

newObject.sayNode();
newObject.sayJS();
console.log(newObject.ES6);
```

* 객체의 메서드에 함수를 연결할 때 더는 :(콜론) 과 function 을 붙이지 않아도 된다.
* 속성명과 변수 명이 같은 경우 한번만 써도 되도록 바뀌었다.
* 예전 문법에서는 위 ES6 라는 속성명을 만들기위해 객체 리터럴 바깥에서 [es + 6] 을 해야 했으나 이제 객체 리터럴 안에서 동적 속성을 선언해도 된다.



## Arrow function

 ```js
 function add1(x, y) {
 	return x + y;
 }
 
 const add2 = (x, y) => {
 	return x + y;
 }
 
 const add3 = (x, y) => x + y;
 
 const add4 = (x, y) => (x + y);
 
 function not1(x) {
 	return !x;
 }
 
 const not2 = x => !x;
 
 console.log(add1(1, 2)); // 3
 console.log(add2(1, 2)); // 3
 console.log(add3(1, 2)); // 3
 console.log(add4(1, 2)); // 3
 console.log(not1(1)); // false
 console.log(not2(1)); // false
 ```

위와 같이 return 문을 생략할 수 있다.

this 바인드 방식에서도 차이가 난다.

```js
let relationship1 = {
	name: 'zero',
	friends: ['nero', 'hero', 'xero'],
	logFriends: function() {
		let that = this;
		this.friends.forEach(function (friend) {
			console.log(that.name, friend);
		});
	},
};
relationship1.logFriends();

const relationship2 = {
	name: 'zero',
	friends: ['nero', 'hero', 'xero'],
	logFriends: function() {
		this.friends.forEach(friend => {
			console.log(this.name, friend);
		});
	},
};
relationship2.logFriends();
```

위 예시를 보면 기존의 방식에서는 forEach 문 내부의 function 과 이전의 function 은 서로 다른 스코프의 this 를 가지므로 forEach 문 내부의 함수에 접근하기 전 that 이라는 변수에 기존의 this 를 담아 사용하고 있는 것을 확인할 수 있다.

하지만 Arrow function 을 사용할 시 상위 스코프의 this를 그대로 물려받아 사용할 수 있다.





## 구조 분해 할당

```js
// 구조 분해 할당
let candyMachine = {
  status: {
    name: "node",
    count: 5,
  },
  getCandy: function () {
    this.status.count--;
    return this.status.count;
  }
};
// var getCandy = candyMachine.getCandy;
// console.log(getCandy());
// var count = candyMachine.status.count;
// console.log(count);
// =>
const {
  getCandy,
  status: { count },
} = candyMachine;
```





## 클래스

다음은 프로토타입 기반 문법을 클래스로 바꾼 것이다.

```js
var Human = function (type) {
  this.type = type || "human";
};

Human.ishuman = function (human) {
  return human instanceof Human;
};

Human.prototype.breathe = function () {
  alert("h-a-a-a-m");
};

var Zero = function (typ, firstName, lastName) {
  Human.apply(this, arguments);
  this.firstName = firstName;
  this.lastName = lastName;
};

Zero.prototype = Object.create(Human.prototype);
Zero.prototype.constructor = Zero; //상속이 이루어지는 부분
Zero.prototype.sayName = function () {
  alert(`${this.firstName} ${this.lastName}`);
};

var oldZero = new Zero("human", "Zero", "Cho");

Human.ishuman(oldZero);
```

현 코드는 prototype 기반으로 Object.create() 를 활용해 상속을 구현한 것이다.

해당 내용에 대한 자세한 내용은 TIL/web/JS_OOP 에서 공부한 바 있다.

이를 CLASS 를 활요하여 구현하면

다음과 같다.

```js
class Human {
  constructor(type = "human") {
    this.type = type;
  }

  static ishuman(human) {
    return human instanceof Human;
  }
  breathe() {
    alert("h-a-a-a-m");
  }
};

class Zero extends Humane {
	constructor(type, firstName, lastName) {
		super(type);
		this.firstName = firstName;
		this.lastName = lastName;
	}

	sayName() {
		super.breathe();
		alert(`${this.firstName} ${this.lastName}`);
	}
};

const newZero = new Zero('human', 'Zero', 'Cho');

Human.ishuman(newZero);
```

생성자 함수는 constructor 안으로 들어갔으며 Human.isHuman 같은 클래스 함수는 static 키워드로 전환되었다.

프로토타입 함수들도 모두 class 블록 안에 포함되어 어떤 함수가 어떤 클래스 소속인지 보기 쉬워졌다.

상속 또한 extends 키워드로 쉽게 가능하다.

다만 이렇게 class 문법으로 바뀌었다고 하여도 js 는 prototype 기반으로 동작한다는 것을 기억해야 한다.



## Promise

자바스크립트와 노드에서는 주로 비동기를 접한다. 특히 이벤트 리스너를 사용할 때 콜백 함수를 자주 사용한다.

ES2015 부터는 자바스크립트와 노드의 API 들이 콜백 대신 Promise 기반으로 재구성 되며, 악명 높은 callback 지옥 현상을 극복했다는 평가를 받고 있다.

Promise 는 반드시 알아두어야 하는 객체이다.

프로미스를 사용하기 위해서는 먼저 프로미스 객체를 생성해야한다.

```js
const condition = true;
const promise = new Promise((resolve, reject) => {
	if (condition) {
		resolve('성공');
	} else {
		reject('실패');
	}
});

promise
	.then((message) => {
		console.log(message);
	})
	.catch((error) => {
		console.log(error);
	})
	.finally(() => {
		console.log('무조건');
	});
	
```

new Promise 를 통해 promise 를 생성할 수 있으며 그 내부에 resolve 와 reject 를 매개변수로 갖는 callback 함수를 넣는다.

이렇게 만든 promise 변수에 then 과 catch 메서드를 붙일 수 있다.

프로미스 내부에서 resolve 가 호출 되면 then 이 실행되고, reject 가 호출 되면 catch 가 실행된다.

finally 는 성공 / 실패 여부와 상관없이 실행된다.

resolve 와 reject 에 넣어준 인수는 각각 then 과 catch 의 매개변수에서 받을 수 있다.

즉, resolve('성공') 이 호출 되면 then 의 message 가 '성공' 이된다. 

만약 reject('실패') 가 호출 되면 catch 의 error 가 '실패' 가 되는 것이다.

condition 변수를 false 로 바꿔 보면 catch 에서 에러가 로깅된다.  

프로미스를 쉽게 설명하자면, 실행은 바로 하되 결괏값은 나중에 받는 객체이다. 결괏값은 실행이 완료된 후 then 이나 catch 메서드를 통해 받는다.

위 예제에서는 new Promise 와 promise.then 사이에 다른 코드가 들어갈 수 있다. new Promise 는 바로 실행되지만 결괏값은 then 을 붙였을 때 받게 된다.

then 이나 catch 에서 다른 then 이나 catch 를 붙일 수 있다. 이전 then 의 return 값을 다음 then 의 매개변수로 넘긴다. 프로미스를 return 한 경우에는 프로미스가 수행된 후 다음 then 이나 catch 가 호출 된다.