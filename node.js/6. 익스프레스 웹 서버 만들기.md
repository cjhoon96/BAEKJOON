# 6. 익스프레스 웹 서버 만들기

****

****



4장에서의 웹 서버를 코드는 가독성도 떨어지고 확장성도 좋지 않다.

npm 에는 서버를 제작하는 과정에서의 불편함을 해소하고 편의 기능을 추가한 웹 서버 프레임워크가 있다.

대표적인 것이 익스프레스이다.

익스프레스는 http 모듈의 요청과 응답 객체에 추가 기능들을 부여했다.

기존 메서드들도 계속 사용할 수 있지만 편리한 메서드들을 추가하여 기능들을 부여했다.

기존 메서드들도 계속 사용할 수 있지만 편리한 메서드들을 추가하여 기능을 보완했다.

또한 코드를 분리하기 쉽게 만들어 관리하기도 용이하다.

더이상 if 문으로 요청 메서드와 주소를 구별하지 않아도 된다.



* ### express 이외에는?

  koa나 hapi 같은 웹서버 프레임워크가 있다.

  하지만 npm 패키지의 다운로드 수를 비교할 수 있는 npmtrends(http://www.npmtrends.com/) 에 따르면 익스프레스가 다른 두 프레임워크에 비해 압도적으로 사용량이 많다.







****

# 6.1 익스프레스 프로젝트 시작하기



***<u>package.json</u>***

```js
{
  "name": "learn-express",
  "version": "0.0.1",
  "description": "express 학습",
  "main": "index.js",
  "scripts": {
    "start": "nodemon app",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "cjhoon",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.19"
  }
}
```

nodemon 모듈로 서버를 자동으로 재시작한다. 

서버 코드를 수정하면 nodemon 이 서버를 자동으로 재시작한다.

nodemon이 실행되는 콘솔에 rs 를 입력해서 수동으로 재시작 할 수 있다.

nodemon 은 개발용으로만 사용하는 것을 권장한다. 

배포 후에는 서버 코드가 빈번하게 변경될 일이 없으므로 nodemon  을 사용하지 않아도 된다.



***<u>app.js</u>***

```js
const express = require('express');

const app = express();
app.set('port', process.env.PORT || 3000);

app.get('/', (req, res) => {
  res.send('Hello, Express');
});

app.listen(app.get('port'), () => {
  console.log(app.get('port'), '번 포트에서 대기 중');
});
```

Express 모듈을 실행해 app 변수에 할당한다. 

익스프레스 내부에 http 모듈이 내장되어 있으므로 서버의 역할을 할 수 있다.

app.set('port', 포트) 로 서버가 실행될 포트를 설정한다.

process.env 객체에 PORT 속성이 있다면 그 값을 사용하고 없다면 기본값 3000 번 포트를 이용하도록 되어있다.

이렇게 **app.set(키, 값) 을 사용해서 데이터를 저장**할 수 있다.

나중에 **데이터를 app.get(키) 로 가져올 수 있다.**



**app.get(주소, 라우터)** 는 주소에 대한 **GET 요청이 올 때 어떤 동작을 할지** 적는 부분이다.

매개변수 **req 는 요청에 관한 정보**가 들어있는 객체이고, **res는 응답에 관한 정보**가 들어있는 객체이다.

현재 GET / 요청 시 응답으로 Hello, Express 를 전송한다.

**익스프레스에서는 res.write나 res.end 대신 res.send 를 사용**하면 된다.

GET 요청 이외에도 POST, PUT, PATCH, DELETE, OPTIONS 에 대한 라우터를 위한 app.post, app.put, app.patch, app.delete, app.options 메서드가 존재한다.

listen 을 하는 부분은 http 웹 서버와 동일하다. 

포트는 app.get('port') 로 가져왔다.

```js
$ npm start

> learn-express@0.0.1 start
> nodemon app

[nodemon] 2.0.19
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node app.js`
3000 번 포트에서 대기 중
```

![6_1](img/6_1.png)



***<u>index.html</u>***

```html
<html>
<head>
  <meta charset="UTF-8" />
  <title>익스프레스 서버</title>
</head>
<body>
  <h1>익스프레스</h1>
  <p>배워봅시다.</p>
</body>
</html>
```

***<u>app.js</u>***

```js
const express = require('express');
const path = require('path')

const app = express();
app.set('port', process.env.PORT || 3000);

app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, '/index.html'));
});

app.listen(app.get('port'), () => {
  console.log(app.get('port'), '번 포트에서 대기 중');
});
```

단순한 문자열 대신 HTML 로 응답하는 경우 **res.sedFile** 메서드를 사용한다.

파일의 경로는 path 모듈을 사용해서 지정한다.

![6_2](img/6_2.png)







****

# 6.2 자주 사용하는 미들웨어



미들웨어는 익스프레스의 핵심이다.

요청과 응답의 중간 (미들 (middle)) 에 위치하여 미들웨어라 부른다.

뒤에 나오는 라우터와 에러 핸들러 또한 미들웨어의 일종이므로 미들웨어가 익스프레스의 전부라고 해도 과언이 아니다.

미들웨어는 요청과 응답을 조작하여 기능을 추가하기도 나쁜 요청을 걸러내기도 한다.



미들 웨어는 **app.use 와 함께 사용**된다.

**app.use(미들웨어)** 방식의 코드를 사용한다.

***<u>app.js</u>***

```js
const express = require('express');
const path = require('path')

const app = express();
app.set('port', process.env.PORT || 3000);

app.use((req, res, next) => {
  console.log('모든 요청에 다 실행');
  next();
});

app.get('/', (req, res, next) => {
  console.log('GET / 요청에서만 실행된다.');
  next();
}, (req, res) => {
  throw new Error('에러는 에러 처리 미들웨어로 간다.')
});

app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).send(err.message);
})

app.listen(app.get('port'), () => {
  console.log(app.get('port'), '번 포트에서 대기 중');
});
```

app.use 에 매개변수가 req, res, next 인 함수를 넣으면 된다.

미들웨어는 위에서부터 아래로 순서대로 실행되면서 요청과 응답 사이에 특별한 기능을 추가할 수 있다.

next 라는 세번째 매개변수는 다음 미들웨어로 넘어가는 함수이다.

next 를 실행하지 않으면 다음 미들웨어가 실행되지 않는다.

주소를 첫번째 인수로 넣어주지 않는다면 미들웨어는 모든 요청에서 실행되고, 주소를 넣는다면 해당하는 요청에서만 실행된다고 보면 된다.

| **app.use(미들웨어)**           | **모든 요청에 미들웨어 실행**                   |
| ------------------------------- | ----------------------------------------------- |
| **app.use('/abc', 미들웨어)**   | **abc 로 시작하는 요청에서 미들웨어 실행**      |
| **app.post('/abc', 미들 웨어)** | **abc 로 시작하는 POST 요청에서 미들웨어 실행** |

app.use 나 app.get 같은 라우터에 미들웨어를 여러개 장착할 수 있다.

이 경우에도 next 를 호출해야 다음 미들웨어로 넘어갈 수 있다.



app.get 라우터에 미들웨어가 두개 연결되어있다.

app.get('/') 의 **두번째 미들웨어에서 에러가 발생**하고, 이 에러는 그 **아래에 있는 에러 처리 비들웨어에 전달**된다.

에러 처리 미들웨어는 매개변수가 err, req, res, next 로 네개이다.

모든 매개변수를 **사용하지 않더라도 매개 변수가 반드시 네개**여야한다.

err 에는 에러에 관한 정보가 담겨있다.

res.status 메서드로 HTTP 상태 코드를 지정할 수 있다.

에러처리 미들웨어를 직접 연결하지 않아도 기본적으로 익스프레스에서 에러를 처리하긴 하지만 실무에서는 직접 에러처리 미들웨어를 연결해 주는 것이 좋다.

특별한 경우가 아니면 가장 아래에 위치시킨다.

![6_3](img/6_3.png)





```js
$ npm i morgan cookie-parser express-session dotenv
```

dotenv 를 제외한 다른 패키지들은 미들웨어이다.

dotenv 는 process.env 를 관리하기 위해 설치한다.

***<u>app.js</u>***

```js
const express = require('express'); 
const morgan = require('morgan');
const cookieParser = require('cookie-parser');
const session = require('express-session');
const dotenv = require('dotenv');
const path = require('path');

dotenv.config();
const app = express();
app.set('port', process.env.PORT || 3000);

app.use(morgan('dev'));
app.use('/', express.static(path.join(__dirname, 'public')));
app.use(express.json());
app.use(express.urlencoded({extended: false}));
app.use(cookieParser(process.env.COOKIESECRET));
app.use(session({
  resave: false,
  saveUninitialized: false,
  secret: process.env.COOKIESECRET,
  cookie: {
    httpOnly: true,
    secure: false,
  },
  name: 'session-cookie',
}));

app.use((req, res, next) => {
  console.log('모든 요청에 다 실행');
  next();
});

app.get('/', (req, res, next) => {
  console.log('GET / 요청에서만 실행된다.');
  next();
}, (req, res) => {
  throw new Error('에러는 에러 처리 미들웨어로 간다.')
});

app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).send(err.message);
})

app.listen(app.get('port'), () => {
  console.log(app.get('port'), '번 포트에서 대기 중');
});
```

***<u>.env</u>***

```
COOKIE_SECRET=cookiesecret
```

req, res, next 같은 매개 변수들은 미들 웨어 내부에 들어있다.

next 도 내부적으로 호출하기에 다음 미들웨어로 넘어갈 수 있다.



dotenv 패키지는 .env 파일을 읽어 process.env 로 만든다.

dotenv 패키지의 이름이 dot+env 인 이유이다.

process.env.COOKIE_SECRET 에 cookiesecret 값이 할당된다.

key=value 구조로 추가하면 된다.

process.env 를 별도의 파일로 관리하는 이유는 보안과 설정의 편의성 때문이다.

비밀 키들을 소스코드에 그대로 적어두면 소스 코드가 유출 되었을 시 키도 같이 유출된다.

따라서 .env 같은 별도의 파일에 비밀 키를 적어두고 dotenv 패키지로 비밀키를 로딩하는 방식으로 관리하곤 한다.



* ## 6.2.1 morgan

  morgan 연결후 localhost:3000에 다시 접속하면 기존 로그 외에 추가적인 로그를 볼 수 있다.

  `GET / 500 25.230 ms - 35` 

  이 로그는 morgan 미들 웨어에서 나오는 것이다.

  요청과 응답에 대한 정보를 콘솔에 기록한다.

  morgan 미들 웨어는 다음과 같이 사용한다.

   ```js
   app.use(morgan('dev'));
   ```

  인수로 dev 외에 **combined, common, short, tiny** 등을 넣을 수 있다.

  인수를 바꾸면 로그가 달라진다.

  dev 모드 기준으로 `GET / 500 25.230 ms - 35`  은 각각 

  [HTTP 메서드] [주소] [HTTP 상태 코드] [응답속도] - [응답 바이트]

  를 의미한다.

  요청과 응답을 한눈에 볼 수 있어 편리하다.





* ## 6.2.2 static

  static 미들웨어는 정적인 파일들을 제공하는 라우터 역할을 한다.

  기본적으로 제공되기에 따로 설치할 필요 없이 express 객체안에서 꺼내 장착하면 된다.

  ```js
  app.use('요청 경로', express.static('실제 경로'));
  app.use('/', express.static(path.join(__dirname, 'public')));
  ```

  함수의 인수로 정적 파일이 담긴 폴더를 지정한다.

  위의 경우 public 폴더가 지정되어있다.

  public 폴더 내부에 stylesheets/style.css 파일이 있다면 localhost:3000/stylesheets/style.css 로 접근할 수 있다.

  즉 서버 폴더 경로와 요청 경로가 다르므로 서버 구조를 쉽게 파악할 수 없어

  보안에 큰 도움이 된다.

  

  또한 정적 파일들을 알아서 제공해주므로 4.3 절 처럼 fs.readFile 로 파일을 직접 읽어서 전송할 필요가 없다.

  파일을 발견한 경우 다음 미들웨어는 실행되지 않고 응답으로 파일을 보낸다.

  만약 요청 파일이 없는 경우 알아서 내부적으로 next 를 호출한다.





* ## 6.2.3 body-parser

  요청의 본문에 있는 데이터를 해석해 req.body 객체로 만들어주는 미들웨어이다.

  보통 폼 데이터나 AJAX 요청의 데이터를 처리한다.

  단, 멀티파트(이미지, 동영상, 파일) 데이터는 처리하지 못한다.

  이 경우에는 multer 모듈을 사용한다.

  

  4.16.0 버전부터 body-parser 미들웨어의 일부 기능이 익스프레스에 내장되어 따로 설치할 필요가 없다.

  JSON 과 URL-encoded 형식의 데이터 외에도 Raw, Text 형식의 데이터를 추가로 해석할 수 있다. 이런 경우 추가로 설치해야한다.

  Raw 는 요청의 본문이 버퍼 데이터일 때, Text 는 텍스트 데이터일 때 해석하는 미들 웨어이다.버퍼나 텍스트 요청을 처리할 필요가 있는 경우

  body-parser 를 설치한 후 `$ npm i body-parser`

  ```js
  const bodyParser = require('body-parser');
  app.use(bodyParser.raw());
  app.use(bodyParser.text());
  ```

  와 같이 처리한다.

  

  ```js
  app.use(express.json());
  app.use(express.urlencoded({extended: false}));
  ```

  `.json() `은 JSON 형식의 데이터 전달 방식이고

  `.urlencoded({extended: false})`은 주소 형식으로 데이터를 보내는 방식이다.(폼 전송에 사용된다)

   `extended: false` 라는 옵션은 노드의 querysting 모듈을 사용하여 쿼리 스트링을 해석하는 방식이며 

  `extended: true` 인 경우 qs 모듈을 사용하여 쿼리 스트링을 해석한다.

  qs 모듈은 내장 모듈이 아니라 npm 패키지이며, querystring 모듈의 기능을 좀 더 확장한 모듈이다.

  

  4.2 절의 POST 와 PUT 요청의 본문을 전달받으려면 req.on('data') 와 req.on('end') 로 스트림을 사용해야했으나

  body-parser 를 사용하면 내부적으로 스트림을 처리해 req.body 에 추가한다.

  예를 들어 JSON 형식으로 `{name: 'zerocho', book: 'nodejs'}`를 본문으로 보낸다면 req.body 에 그대로 들어간다.

  URL-encoded 형식으로 `name=zerocho&book=node.js` 를 본문으로 보낸다면 req.body에 `{name: 'zerocho', book: 'nodejs'}`가 들어간다.





* ## 6.2.4 cookie-parser

  cookie-parser 는 요청에 동봉된 쿠키를 해석해 `req.cooies` 객체로 만든다.

  4.3 절의 parseCookies 함수와 기능이 비슷하다.

  cookie-parser 미들웨어는 다음과 같이 사용한다.

  ```js
  app.use(cookieParser(비밀키));
  ```

  해석된 쿠키들은 req.cookies 객체에 들어간다.

  예를 들어 `name=zerocho` 쿠키를 보냈다면 `req.cookies`는 `{name: 'zerocho'}`가 된다.

  유효기간이 지난 쿠키는 알아서 걸러낸다.

  첫번째 인수로 비밀 키를 넣어줄 수 있다.

  서명된 쿠키가 있는 경우, 제공한 비밀 키를 통해 해당 쿠키가 내 서버가 만든 쿠키임을 검증할 수 있다.

  쿠키는 클라이언트에서 위조하기 쉬우므로 비밀키를 통해 만들어낸 서명을 쿠키 값 뒤에 쿹인다. 

  서명이 붙으면 쿠키가 `name=zerocho.sign`과 같은 모양이 된다. 

  서명된 쿠키는 `req.cookies`대신 `req.signedCookies` 객체에 들어 있다.

  

  cookie-parser 가 쿠키를 생성할 때 쓰이는 것은 아니다.

  쿠키를 생성/제거 하기 위해서는 `res.cookie`, `res.clearCookie` 메서드를 사용해야 한다.

  `res.cookie(키, 값, 옵션)` 형식으로 사용한다.

  옵션은 4.3 절에서 살펴본 쿠키 옵션과 동일하다.

  domain, expires, httpOnly, maxAge, path, secure 등이 있다.

  

  ```js
  res.cookie('name', 'zerocho', {
      expires: new Date(Date.now() + 900000),
      httpOnly: true,
      secure: true,
  });
  resclearCookie('name', 'zerocho', {httpOnly: true, secure: true});
  ```

  쿠키를 지우려면, 키와 값 외에 옵션도 정확히 일치해야 쿠키가 지워진다. 

  단, expires 나 maxAge 옵션은 일치할 필요가 없다.

  

  옵션중에는 signed라는 옵션이 있는데, 이를 true 로 설정하면 쿠키 뒤에 서명이 붙는다. 

  내 서버가 쿠키를 만들었다는 것을 검증할 수 있으므로 대부분의 경우 서명 옵션을 켜두는 것이 좋다.

  서명을 위한 비밀 키는 cookieParser 미들웨어에 인수로 넣은 `process.env.COOKIE_SECRET` 이 된다.













****

# 6.3 Router 객체로 라우팅 분리









****

# 6.4 req, res 객체 살펴보기





****

# 6.5 템플릿 엔진 사용하기

