# 3. 노드 기능 알아보기

****

****



# REPL 사용하기

스크립트 언어인 자바스크립트는 컴파일 하지 않아도 즉석에서 코드 실행이 가능

노드 또한 브라우저 콘솔 탭과 비슷한 콘솔을 제공한다.

코드를 Read(읽기) / Eval(해석) / Print(반환) 종료할 때 까지 Loop(반복) => REPL 이라고 부른다.

![3_1](.\img\3_1.png)

REPL 은 한두 줄 짜리 코드를 테스트 해보는 용도로는 좋지만 여러줄의 코드를 실행하기에는 불편하다.







*****

# JS 파일 실행하기



*<u>**3\_2\_helloWorld**</u>*

```js
function helloWorld() {
    console.log('Hello World');
    helloNode();
}

function helloNode() {
    console.log('Hello Node');
}

helloWorld();
```

![3_2](.\img\3_2.png)

REPL 로 들어가는 명령어 node 뒤에 실행하고자 하는 JS 파일의 경로를 입력하면 REPL 에서 해당 JS 파일을 실행하여 결과가 출력되는 것을 확인할 수 있다.







****

# 모듈로 만들기

노드는 코드를 모듈로 만들 수 있다는 점에서 브라우저에서의 자바스크립트와 다르다.

* ### 모듈

  특정한 기능을 하는 함수나 변수들의 집합

  자체로도 하나의 프로그램이면서 다른 프로그램의 부품으로도 사용 가능



***<u>3\_3\_var.js</u>***

```js
const odd = '홀수입니다.';
const even = '짝수입니다.';

module.exports = {
    odd,
    even,
};
```

var.js 에 변수 두개를 선언한 후 module.exports 에 변수들을 담은 객체를 대입했다.

이제 이 파일은 모듈로서 기능을 한다.

***<u>3_3_func.js</u>***

```js
const { odd, even } = require('./3_3_var');

function checkOddOrEven(num) {
    if (num % 2) {
        return odd;
    }
    return even;
}

module.exports = checkOddOrEven;
```

require 함수 안에 불러올 모듈의 경로를 적는다. 위 예제에서는 같은 exercise 폴더 안에 있으므로 상대 경로를 통해 ./(현 위치)3_2_var.js 에 접근한다.

이후 구조분해 할당을 이용해 { odd, even } 에 3_2_var 에서 module.exports 에 담은 { odd, even } 을 할당한다.



이후 정의한 checkOddOrEven 함수를 다시 module.exports 에 담는다.

 module.exports 는 객체만 대입해야 하는 것이 아니라 함수, 변수 를 대입할 수도 있다.



***<u>3\_3\_index.js</u>***

```js
const {odd, even} = require('./3_3_var');
const checkNumber = require('./3_3_func');

function checkStringOddOrEven(str) {
    if (str.length % 2 ) {
        return odd;
    }
    return even;
}

console.log(checkNumber(10));
console.log(checkStringOddOrEven('hello'));
```

![3_3](.\img\3_3.png)

이렇게 여러 파일에 걸쳐 재사용되는 함수나 변수를 모듈로 만들어두면 편리하다.그러나 모듈이 많아지고 모듈간 관계가 얽히게 되면 구조를 파악하기 어렵다는 단점도 있다.

* ## ES2015 모듈

  ES2015 가 도입되면서 자바스크림트도 자체 모듈 시스템 문법이 생겼다. 

  func.js 를 ES2015 모듀 ㄹ스타일로 바꿔보면

  ```js
  import {odd, even} from './var';
  
  function checkOddOrEven(num) {
      if (num % 2) {
          return odd;
      }
      return even;
  }
  
  export default checkOddOrEven;
  ```

  가 된다. require 함수가 ***import from*** 구문으로 module.export 가 ***export default*** 구문으로 바뀐것을 볼 수 있다.







****

# 노드 내장 객체 알아보기



노드에서는 기본적인 내장 객체와 내장 모듈을 제공한다.

따로 설치 하지 않아도 바로 사용할 수 있으며 브라우저의 window 객체와 비슷하다고 보면된다.



* ## global

  global 은 브라우저의 window 같은전역객체로 모든 파일에서 접근 가능하다.

  또한 window.open 메서드를 그냥 open 으로 호출할 수 있는 것처럼 global 또한 생략 가능하다.

  이전 절의 require 함수나 console 객체도 global 을 생략한 것이다.\

  global 객체 의 내부를 보려면 REPL 에 들어가 global 을 입력하면 된다.

  ```
  > global.console
  Object [console] {
    log: [Function: log],
    warn: [Function: warn],
    dir: [Function: dir],
    time: [Function: time],
    timeEnd: [Function: timeEnd],
    timeLog: [Function: timeLog],
    trace: [Function: trace],
    assert: [Function: assert],
    clear: [Function: clear],
    count: [Function: count],
    countReset: [Function: countReset],
    group: [Function: group],
    groupEnd: [Function: groupEnd],
    table: [Function: table],
    debug: [Function: debug],
    info: [Function: info],
    dirxml: [Function: dirxml],
    error: [Function: error],
    groupCollapsed: [Function: groupCollapsed],
    Console: [Function: Console],
    profile: [Function: profile],
    profileEnd: [Function: profileEnd],
    timeStamp: [Function: timeStamp],
    context: [Function: context]
  }
  >
  ```

  전역 객체라는 점을 이용하여 파일간에 간단한 데이터를 공유할 때 사용하기도 한다.

  ***<u>3\_4\_globalA.js</u>***

  ```js
  module.exports = () =>  global.message;;
  ```

  ***<u>3\_4\_globalB.js</u>***

  ```js
  const A = require('./3_4_globalA');
  
  global.message = '안녕하세요';
  console.log(A());
  ```

  globalA 모듈의 함수는 global.message 를 반환한다.

  globalB.js 에서는 global 객체에 속성명이 message 인 값을 대입하고 globalA 모듈의 함수를 호출한다. 콘솔 결과는 globalB 에서 넣은 global.message 값을 globalA 에서도 접근할 수 있음을 보여준다.

  ![3_4](img/3_4.png)





* ## console

  지금까지 사용했던 console 도 노드에서는 window 대신 global 객체 안에 들어 있으며, 브라우저에서의 console 과 비슷하다.

  console 객체는 보통 디버깅을 위해 사용한다. 

  * 변수에 값이 제대로 들어있는지 확인하기 위해
  * 에러 발생시 에러 내용을 콘솔에 표시하기 위해 
  * 코드 실행 시간을 알아보기 위해

  사용한다.

  ***<u>3\_4\_console.js</u>***

  ```js
  const string = 'abc';
  const number = 1;
  const boolean = true;
  const obj = {
      outside: {
          inside: {
              key: 'value',
          },
      },
  };
  console.time('전체 시간');
  console.log('평볌한 로그이다. 쉼표로 구분해 여러 값을 찍을 수 있다.');
  console.log(string, number, boolean);
  console.error('에러 메시지는 console.error에 담는다.');
  
  console.table([{ name: '제로', birth: 1994 }, { name: 'hero', birth: 1988 }]);
  
  console.dir(obj, { colors: false, depth: 2 });
  console.dir(obj, { colors: true, depth: 1 });
  
  console.time('시간 측정');
  for (let i = 0; i < 100000; i++) {}
  console.timeEnd('시간 측정');
  
  function b() {
      console.trace('에러 위치 추적');
  }
  function a() {
      b();
  }
  a();
  
  console.timeEnd('전체 시간');
  ```

  ![3_5](img/3_5.png)

  * ### console.time(레이블) :

    console.timeEnd(레이블) 과 대응되어 같은 레이블을 가진 time 과 timeEnd 사이의 시간을 측정한다.

  * ### console.log(내용):

    평범한 로그를 콘솔에 표시한다. console.log(내용, 내용, ...) 처럼 여러 내용을 동시에 표시할 수 있다.

  * ### console.error(에러 내용):

    에러를 콘솔에 표시한다.

  * ### console.table(배열):

    배열의 요소로 객체 리터럴을 넣으면, 객체의 속성들이 테이블 형식으로 표현된다.

  * ### console.dir(객체, 옵션) :

    객체를 콘솔에 표시할 때 사용한다. 첫번째 인수로 표시할 객체를 넣고, 두번째 인수로 옵션을 넣는다.

    옵션의 colors를 true 로 하면 콘솔에 색이 추가되어 보기가 편해진다. 

    depth 는 객체 안의 객체를 몇단계까지 보여줄지를 결정한다. 

    기본값은 2이다.

  * ### console.trace(레이블):

    에러가 어디서 발생했는지 추적할 수 있게 한다.

    일반적으로 에러 발생시 에러 위치를 알려주므로 자주 사용하지는 않지만 위치가 나오지 않는다면 사용할 만하다.





* ## 타이머 

  타이머 기능을 제공하는 함수인 setTimeout, setInterval, setImmediate 노드에서 window 대신 global 객체 안에 들어있다. setTimeout 과 setInterval 은 웹 브라우저에서도 자주 사용된다.

  * ### setTimeout(콜백함수, 밀리초):

    주어진 밀리초(1/1000초) 이후에 콜백 함수를 실행한다.

  * ### setInterval(콜백함수, 밀리초):

    주어진 밀리초마다 콜백함수를 반복 실행한다.

  * ### setImmediate(콜백함수):

    콜백 함수를 즉시 실행한다.

  이 타이머 함수들은 모두 아이디를 반환한다.

  아이디를 사용하여 타이머를 취소할 수 있다.

  * ### clearTimeout(아이디):

    setTimeout 취소

  * ### setInterval(아이디):

    setTimeout 취소

  * ### clearImmediate(아이디):

    setImmediate 취소

  

  ***<u>3\_4\_timer.js</u>***

  ```js
  const timeout = setTimeout(() => {
      console.log('1.5초 후 실행');
  }, 1500);
  
  const interval = setInterval(() => {
      console.log('1초 마다 실행');
  }, 1000);
  
  const timeout2 = setTimeout(() => {
      console.log('실행되지 않는다.');
  }, 3000);
  
  setTimeout(() => {
      clearTimeout(timeout2);
      clearInterval(interval);
  }, 2500);
  
  const immediate = setImmediate(() => {
      console.log('즉시 실행');
  });
  
  const immediate2 = setImmediate(() => {
      console.log('실행되지 않는다.');
  });
  
  clearImmediate(immediate2);
  ```

  |  초  | 실행                                  | Console        |
  | :--: | ------------------------------------- | -------------- |
  |  0   | immediate<br/>*immediate2(취소)*      | 즉시 실행      |
  |  1   | interval                              | 1초마다 실행   |
  | 1.5  | timeout                               | 1.5초마다 실행 |
  |  2   | interval                              | 1초마다 실행   |
  | 2.5  | *timeout2(취소)*<br/>*interval(취소)* |                |

  

  * ### setImmediate(콜백) 과 setTimeout(콜백,0) 차이

    파일 시스템 접근, 네트워킹 같은 I / O 작업의 콜백 함수 안에서 타이머를 호출 하는 경우에 setImmediate 는 setTimeout(콜백, 0) 보다 먼저 실행된다.

    하지만 setImmediate 가 항상 setTimeout(콜백, 0) 보다 먼저 호출되지는 않는다는 사실을 기억해야한다. 

    setTimeout(콜백, 0)은 사용하지 않는 것을 권장한다.





* ## \_\_filename, \_\_dirname

  노드에서는 파일 사이에 모듈 관계가 있는 경우가 많으므로 때로는 현재 파일의 경로나 파일명을 알아야 한다. 

  노드는 \_\_filename, \_\_dirname라는 키워드로 경로에 대한 정보를 제공한다.

  파일에 \_\_filename, \_\_dirname 을 넣어두면 실행 시 현 파일명과 현재 파일 경로로 바뀐다.

  ***<u>3\_4\_filename.js</u>***

  ```
  console.log(__filename);
  console.log(__dirname);
  ```

  ![3_6](img/3_6.png)

  이렇게 얻은 정보를 사용해서 경로 처리를 할 수도 있다. 하지만 경로가 문자열로 반환되기도 하고, \ 나 / 같은 경로 구분자 문제도 있으므로 보통은 이를 해결해주는 path 모듈 (3.5.2) 과 함께 사용한다.





* ## module, exports, require

  

  ## exports

  ***<u>3\_3\_var.js</u>***

  ```js
  const odd = '홀수입니다.';
  const even = '짝수입니다.';
  
  module.exports = {
      odd,
      even,
  };
  ```

  를 다음과 같이 수정해도  index.js 에서는 동일하게 불러올 수 있다.

  ***<u>3\_4\_var.js</u>***

  ```js
  exports.odd = '홀수입니다.';
  exports.even = '짝수입니다.';
  ```

  

  module.exports 로 한번에 대입하는 대신, 각각의 변수를 exports 객체에 하나씩 넣을 수 있다.

  module.exports 와 exports 가 같은 객체를 참조하기 때문이다.

  실제로 console.log(module.exports === exports) 를 하면 true 가 나온다. 

  

  * ### exports 객체 사용시 주의점

    **exports =(참조)=> module.exports =(참조)=> {  }** 

    exports 객체를 사용할 때는 module.exports 와의 참조 관계가 깨지지 않도록 주의

    module.exports 에는 어떤 값이든 대입해도 되지만 exports 에는 반드시 객체처럼 속성명과 속성값을 대입해야한다.

    exports 에 다른 값을 대입하면 객체의 참조 관계가 끊겨 더 이상 모듈로 기능하지 않는다.

  

  

  * ###  노드에서 this 는 무엇인가?

    노드에서 this 를 사용할 때 주의하여야 할 점

    ***<u>3\_4\_this.js</u>***

    ```js
    console.log(this);
    console.log(this === module.exports);
    console.log(this === exports);
    
    function whatIsThis() {
        console.log('function', this === exports, this === global);
    }
    whatIsThis();
    ```

    ```
    {}
    true
    true
    function false true
    ```

    다른 부분은 브라우저의 자바스크립트와 동일하지만 최상위 스코드에 존재하는 this는 module.exports 를 가리킨다. 또한 함수 선언문 내부의 this는 global 객체를 가리킨다.

  

  ## require

  require 은 함수이며 함수는 객체이므로 require은 객체로서 몇가지 속성을 갖고 있다.

  * ### require.cache / require.main

    ***<u>3\_4\_require.js</u>***

    ```js
    console.log('require 이 가장 위에 오지 않아도 된다.');
    
    module.exports = 'find me';
    
    require('./3_4_var');
    
    console.log('require.cache 이다.');
    console.log(require.cache);
    console.log('require.main 이다.');
    console.log(require.main === module);
    console.log(require.main.filename);
    ```

    ```
    require 이 가장 위에 오지 않아도 된다.
    require.cache 이다.
    [Object: null prototype] {
      'c:\\Users\\jihoon\\TIL\\node.js\\exercise\\tempCodeRunnerFile.js': Module {
        id: '.',
        path: 'c:\\Users\\jihoon\\TIL\\node.js\\exercise',
        exports: 'find me',
        filename: 'c:\\Users\\jihoon\\TIL\\node.js\\exercise\\tempCodeRunnerFile.js',
        loaded: false,
        children: [ [Module] ],
        paths: [
          'c:\\Users\\jihoon\\TIL\\node.js\\exercise\\node_modules',
          'c:\\Users\\jihoon\\TIL\\node.js\\node_modules',
          'c:\\Users\\jihoon\\TIL\\node_modules',
          'c:\\Users\\jihoon\\node_modules',
          'c:\\Users\\node_modules',
          'c:\\node_modules'
        ]
      },
      'c:\\Users\\jihoon\\TIL\\node.js\\exercise\\3_4_var.js': Module {
        id: 'c:\\Users\\jihoon\\TIL\\node.js\\exercise\\3_4_var.js',
        path: 'c:\\Users\\jihoon\\TIL\\node.js\\exercise',
        exports: { odd: '홀수입니다.', even: '짝수입니다.' },
        filename: 'c:\\Users\\jihoon\\TIL\\node.js\\exercise\\3_4_var.js',
        loaded: true,
        children: [],
        paths: [
          'c:\\Users\\jihoon\\TIL\\node.js\\exercise\\node_modules',
          'c:\\Users\\jihoon\\TIL\\node.js\\node_modules',
          'c:\\Users\\jihoon\\TIL\\node_modules',
          'c:\\Users\\***\\node_modules',
          'c:\\Users\\node_modules',
          'c:\\node_modules'
        ]
      }
    }
    require.main 이다.
    true
    c:\Users\***\TIL\node.js\exercise\tempCodeRunnerFile.js
    ```

    

  









3\_4\_