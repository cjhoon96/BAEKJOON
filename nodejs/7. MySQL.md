# 7. MySQL

****

****



****

# 7.1 데이터베이스란



데이터베이스란 관련성을 가지며 중복이 없는 데이터의 집합이다.

데이터베이스를 관리하는 시스템을 DBMS(**D**ata**B**ase **M**anagement **S**ystem) 라 부른다.

보통 서버의 하드디스크나 SSD 등의 저장매체에 데이터를 저장한다.







****

# 7.2 MySQL 설치하기







****

# 7.3 워크벤치 설치하기







****

# 7.4 데이터베이스 및 테이블 생성하기



* ### PK(PRIMARY KEY)

  기본키 여부를 체크

* ### NN(NOT NULL)

  빈칸을 허용할지 여부

* ### UQ(UNIQUE INDEX)

  UNIQUE INDEX

  해당 값이 고유해야 하는 지에 대한 옵션

* ### UN(UNSIGNED)

  UNSIGNED

* ### ZF(ZEROFILL)

  ZEROFILL 숫자의 자릿수가 고정되어있을 때 사용

  비어있는 자리에는 0 이 들어간다.

* ### AI(AUTO_INCREMENT)

  숫자를 자동으로 올리는 기능



```mysql
CREATE TABLE `nodejs`.`users` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `name` VARCHAR(20) NOT NULL,
  `age` INT(10) UNSIGNED NOT NULL,
  `married` TINYINT(1) NOT NULL,
  `comment` TEXT NULL,
  `created_at` DATETIME NOT NULL DEFAULT now(),
  PRIMARY KEY (`id`),
  UNIQUE INDEX `name_UNIQUE` (`name` ASC) VISIBLE)
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8
COLLATE = utf8_bin
COMMENT = '사용자 정보';
```





****

# 7.5 CRUD 작업하기



워크벤치를 활용한 CRUD 실습

프롬프트에서의 작업보다 간단하여 수정, 작업의 편의성이 높아졌다. 







****

# 7.6 시퀄라이즈 사용하기



시퀄라이즈는 ORM (**O**bject-**r**elational **M**apping) 으로 분류된다. 

ORM 은 자바스크립트 객체와 데이터베이스의 릴레이션을 매핑해주는 도구이다.



시퀄라이즈는 MySQL 이외에도 MariaDB, PostgreSQL, SQLite, MSSQL 등 다른 데이터 베이스도 함께 사용 가능하다.

문법이 어느정도 호환되므로 프로젝트를 다른 SQL 데이터베이스로 전환할때도 편리하다.



시퀄라이즈를 쓰느느 이유는 자바스크립트 구문을 알아서 SQL 로 바꿔주기 때문이다.

따라서 SQL 언어를 직접 사용하지 않아도 자바스크립트만으로 MySQL 을 조작할 수 있고, SQL 을 몰라도 MySQL 을 어느정도 다룰 수 있게 된다. 

물론 SQL 을 모드는 채로 시퀄라이즈를 사용하는 것은 권장하지 않는다.





```
$ npm i express morgan numjucks sequelize sequelize-cli mysql2
$ npm i -D nodemon
```

* ### sequelize-cli  

  시퀄라이즈 명령어를 실행하기 위한 패키지

* ### mysql2 

  MySQL 과 시퀄라이즈를 이어주는 드라이버



```
$ npx sequelize init
```

config, models, migrations, seeders 폴더가 생성된다.

sequelize-cli 가 자동으로 생성해 주는 코드는 그대로 사용할 때 에러가 발생하고 필요 없는 부분도 많다.

따라서 models/index.js 의 코드를 일부 수정한다.



***<u>models/index.js</u>***

```js
const Sequelize = require('sequelize');

const env = process.env.NODE_ENV || 'development';
const config = require('/../config/config')[env];
const db = {};

db.sequelize = new Sequelize(config.database, config.username, config.password, config);

module.exports = db;
```

Sequelize 는 시퀄라이즈 패키지이자 생성자이다.

config/config.json 에서 데이터베이스 설정을 불러온 후 new Sequelize 를 통해 MySQL 연결 객체를 생성한다.

연결 객체를 나중에 재사용 하기 위해 db.sequelize 에 넣어둔다.



* ## 7.6.1 MySQL 연결하기

  시퀄라이즈를 통해 익스프레스 앱과 MySQL 을 연결해야한다.

  

  ***<u>app.js</u>***

  ```js
  const express = require('express');
  const path = require('path');
  const morgan = require('morgan');
  const nunjucks = require('nunjucks');
  
  const { sequelize } = require('./models');
  
  const app = express();
  app.set('port', process.env.PORT || 3001);
  app.set('view engine', 'html');
  nunjucks.configure('views', {
    express: app,
    watch: true,
  });
  sequelize.sync({ force: false })
    .then(() => {
      console.log('데이터베이스 연결 성공');
    })
    .catch((err) => {
      console.error(err);
    });
  
  app.use(morgan('dev'));
  app.use(express.static(path.join(__dirname, 'public')));
  app.use(express.json());
  app.use(express.urlencoded({ extended: false }));
  
  app.use((req, res, next) => {
    const error =  new Error(`${req.method} ${req.url} 라우터가 없음`);
    error.status = 404;
    next(error);
  });
  
  app.use((err, req, res, next) => {
    res.locals.message = err.message;
    res.locals.error = process.env.NODE_ENV !== 'production' ? err : {};
    res.status(err.status || 500);
    res.render('error');
  });
  
  app.listen(app.get('port'), () => {
    console.log(app.get('port'), '번 포트에서 대기 중');
  });
  ```

  `require('./models')` 는 `require('./models/index.js')`와 같다. 

  폴더 내의 index.js 파일은 require 시 이름을 생략할 수 있다.

  `db.sequelize` 를 불러와 sync 메서드를 사용해 서버 실행 시 MySQL 과 연동되도록 되어있다.

  내부에 `force: false` 옵션은 true 로 설정시 서버 실행시마다 테이블을 재생성한다.

  테이블을 잘못만든 경우에 true 로 설정하면 된다.

  

  MySQL 과 연동할 때는 config 폴더 안의 config.json 정보가 사용된다.

  

  ***<u>config/config.json</u>***

  ```js
  {
    "development": {
      "username": "root",
      "password": "[root 비밀번호]",
      "database": "nodejs",
      "host": "127.0.0.1",
      "dialect": "mysql"
    },
    "test": {
      "username": "root",
      "password": null,
      "database": "database_test",
      "host": "127.0.0.1",
      "dialect": "mysql"
    },
    "production": {
      "username": "root",
      "password": null,
      "database": "database_production",
      "host": "127.0.0.1",
      "dialect": "mysql"
    }
  }
  ```

  development 속성을 위와 같이 변경한다. 

  test 와 production 쪽은 각각 테스트 용도와 배포 용도로 접속하기 위해 사용되는 것이다.

  development.password 와 development.database 는 MySQL 커넥션과 일치하게 수정한다.

  이 설정은 **process.env.NODE_ENV 가 development 일 때 적용**된다. (기본적으로 development 이다.)

  나중에 배포할 때는 process.env.NODE_ENV 를 production 으로 설정해둔다. 

  따라서 배포환경을 위해 데이터베이스를 설정할 때는 config/config.json 의 production 속성을 수정하면 된다. 

  마찬가지로 테스트환경(process.env.NODE_ENV가 test) 일 때는 test 속성을 수정한다.

  

  ```js
  $ npm start
  
  > learn-sequelize@0.0.1 start
  > nodemon app
  
  [nodemon] 2.0.19
  [nodemon] to restart at any time, enter `rs`
  [nodemon] watching path(s): *.*
  [nodemon] watching extensions: js,mjs,json
  [nodemon] starting `node app.js`
  3001 번 포트에서 대기 중
  Executing (default): SELECT 1+1 AS result
  데이터베이스 연결 성공
  ```





* ## 7.6.2 모델 정의하기

  이제 MySQL 에서 정의한 테이블을 시퀄라이즈에서도 정의해야 한다. 

  MySQL 의 테이블은 시퀄라이즈의 모델과 대응된다.

  시퀄라이즈는 모델과 MySQL 의 테이블을 연결해주는 역할을 한다.

  

  시퀄라이즈는 기본적으로 모델 이름은 단수로 테이블 이름은 복수형으로 사용한다. 

  

  ***<u>moduels/user.js</u>***

  ```js
  const Sequelize = require('sequelize');
  
  module.exports = class User extends Sequelize.Model {
    static init(sequelize) {
      return super.init({
        name: {
          type: Sequelize.STRING(20),
          allowNull: false,
          unique: true,
        },
        age: {
          type: Sequelize.INTERGER.UNSIGNED,
          allowNull: false,
        },
        age: {
          type: Sequelize.INTEGER.UNSIGNED,
          allowNull: false,
        },
        married: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
        },
        comment: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.NOW,
        },
      }, {
        sequelize,
        timestamps: false,
        underscored: false,
        modelName: 'User',
        tableName: 'users',
        paranoid: false,
        charset: 'utf8',
        collate: 'utf8_general_ci',
      });
    }
    static associate(db) {}
  };
  ```

  User 모델을 만들고 모듈로 exports 한다.

  User 모델은 Sequelize.Model 을 확장한 클래스로 선언한다. 

  static init 메서드와 static associate 메서드로 나뉜다.

  

  init 메서드에는 테이블에 대한 설정을 하고 association 메서드에는 다른 모델과의 관계를 적는다.

  * ### init

    super.init 메서드의 첫 인수가 테이블 컬럼에 대한 설정이다.

    시퀄라이즈의 자료형은 MySQL 의 자료형과는 조금 다르다. 

    ### MySQL TYPE  &  시퀄라이즈 TYPE

    |     MySQL     |         시퀄라이즈          |
    | :-----------: | :-------------------------: |
    | VARCHAR(100)  |         STRING(100)         |
    |      INT      |           INTEGER           |
    |    TINYINT    |           BOOLEAN           |
    |   DATETIME    |            DATE             |
    | INT UNSIGNED  |      INTEGER.UNSIGNED       |
    |   NOT NULL    |      allowNull: false       |
    |    UNIQUE     |        unique: true         |
    | DEFAULT now() | defaultValue: Sequelize.NOW |

    

    두번째 인수는 테이블 옵션이다.

    * ### sequelize : 

      static init 메서드의 매개변수와 연결되는 옵션으로 db.sequelize 객체를 넣어야 한다.

    * ### timestamps : 

      현재 false 로 되어있으며 이 속성 값이 true 면 시퀄라이즈는 createAt 과 updatedAt 컬럼을 추가한다.

      각각 로우가 생성될 때와 수정될 때의 시간이 자동으로 입력된다.

      예제와 같이 created_at 컬럼을 생성한 경우 timestamps 속성이 필요 없다.

    * ### underscored :

      시퀄라이즈는 기본적으로 테이블명과 컬럼명을 캐멀 케이스(camel case) 로 만든다. 

      이를 스네이크 케이스(snake case)로 바꾸는 옵션이다.

      createdAt => created_at 

    * ### modelName : 

      모델 이름을 설정할 수 있다.

      노드 프로젝트에서 사용한다.

    * ### tableName : 

      실제 데이터베이스의 테이블 이름이다.

      기본적으로 모델 이름을 소문자 및 복수형으로 만든다. 

      모델 이름 User 라면 테이블 이름은 users 가 된다. 

    * ### paranoid : 

      true 로 설정하면 deletedat 이라는 컬럼이 생긴다. 

      로우를 삭제할 때 완전히 지워지지 않고 deletedAt 에 지운 시각이 기록된다.

      로우를 조회하는 명령을 내렸을 때는 deletedAt 의 값이 null 인 로우 (삭제되지 않았다는 뜻) 를 조회한다.

      이렇게 하는 이유는 나중에 로우를 복원하기 위해서이다.

    * ### charset 과 collate : 

      utf8 과 utf8_general_ci로 설정해야 한글이 입력된다.

      이모티콘까지 입력할 수 있게 하고 싶다면 utf8mb4와 utf8mb4_general_ci 를 입력한다.    

    

  ***<u>models/comment.js</u>***

  ```js
  const Sequelize = require('sequelize');
  
  module.exports = class Comment extends Sequelize.Model {
    static init(sequelize) {
      return super.init({
        comment: {
          type: Sequelize.STRING(100),
          allowNull: false,
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: true,
          defaultValue: Sequelize.NOW,
        },
      }, {
        sequelize,
        timestamps: false,
        modelName: 'Comment',
        tableName: 'comments',
        paranoid: false,
        charset: 'utf8mb4',
        collate: 'utf8mb4_general_ci',
      });
    }
  
    static associate(db) {}
  };
  ```

  Comment 모델에는 users 테이블과 연결되어있는 commenter 컬럼이 없다.
  
  이 부분은 모델을 정의할 때 넣어도 되지만 시퀄라이즈 자체에서 관계를 따로 정의할 수 있다.
  
  
  
  모델을 생성했다면 models/index.js 와 연결한다.
  
  
  
  ***<u>models/index.js</u>***
  
  ```js
  const Sequelize = require('sequelize');
  const User = require('./user');
  const Comment = require('./comment');
  
  const env = process.env.NODE_ENV || 'development';
  const config = require('../config/config')[env];
  const db = {};
  
  db.sequelize = new Sequelize(config.database, config.username, config.password, config);
  
  db.User = User;
  db.Comment = Comment;
  
  User.init(sequelize);
  Comment.init(seq7uelize);
  
  User.associate(db);
  Comment.associate(db);
  
  module.exports = db;
  ```
  
  db 라는 객체에 User 와 Comment 모델을 담아두었다. 
  
  앞으로 db 객체를 require 하여 User 와 Comment 모델에 접근할 수 있다.
  
  User.init 과 Comment.init 은 각각의 모델의 static.init 메서드를 호출하는 것이다. 
  
  init 이 실행되어야 테이블이 모델로 연결된다.
  
  다른 테이블과의 관게를 연결하는 associate 메서드도 미리 실행해둔다.





* ## 7.6.3 관계 정의하기 

  MySQL 에서는 JOIN 기능으로 여러 테이블 간 관계를 파악해 결과를 도출한다.

  시퀄라이즈는 JOIN 기능도 알아서 구현한다.

  대신 테이블 간에 어떠한 관계가 있는지 알려야한다.

  

  ### 1:N

  시퀄라이즈에서는 1:N 관계를 hasMany 라는 메서드로 표현한다.

  users 테이블의 로우 하나를 불러올 때 연결된 comments 테이블의 로우들도 같이 불러올 수 있다.

  반대로 belongsTo 메서드도 있다.

  comments 테이블의 로우를 불러올 때 연결된 users 테이블의 로우를 가져온다.

  |  1   |      |     :     |      |    N    |
  | :--: | :--: | :-------: | :--: | :-----: |
  | User | ===  |  hasMany  | ==>  | Comment |
  | User | <==  | belongsTo | ===  | Comment |

  

  모델 각각의 static associate 메서드에 넣는다.

  ***<u>models/user.js</u>***

  ```js
  const Sequelize = require('sequelize');
  
  module.exports = class User extends Sequelize.Model {
    static init(sequelize) {
      return super.init({
        name: {
          type: Sequelize.STRING(20),
          allowNull: false,
          unique: true,
        },
        age: {
          type: Sequelize.INTERGER.UNSIGNED,
          allowNull: false,
        },
        age: {
          type: Sequelize.INTEGER.UNSIGNED,
          allowNull: false,
        },
        married: {
          type: Sequelize.BOOLEAN,
          allowNull: false,
        },
        comment: {
          type: Sequelize.TEXT,
          allowNull: true,
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false,
          defaultValue: Sequelize.NOW,
        },
      }, {
        sequelize,
        timestamps: false,
        underscored: false,
        modelName: 'User',
        tableName: 'users',
        paranoid: false,
        charset: 'utf8',
        collate: 'utf8_general_ci',
      });
    }
    static associate(db) {
      db.User.hasMany(db.Comment, { foreignKey: 'commenter', sourceKey: 'id' });
    }
  };
  ```

  ***<u>models/comment.js</u>***

  ```js
  const Sequelize = require('sequelize');
  
  module.exports = class Comment extends Sequelize.Model {
    static init(sequelize) {
      return super.init({
        comment: {
          type: Sequelize.STRING(100),
          allowNull: false,
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: true,
          defaultValue: Sequelize.NOW,
        },
      }, {
        sequelize,
        timestamps: false,
        modelName: 'Comment',
        tableName: 'comments',
        paranoid: false,
        charset: 'utf8mb4',
        collate: 'utf8mb4_general_ci',
      });
    }
  
    static associate(db) {
      db.Comment.belongsTo(db.User, { foreignKey: 'commenter', targertKey: 'id' });
    }
  };
  ```

  